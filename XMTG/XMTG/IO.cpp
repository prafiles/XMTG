#ifndef IO_CPP_ //Preventing multi-inclusion
#define IO_CPP_

#include "Header.h"

//Define End of Line as per the environment
#ifdef _WIN32
#define ENDLINE "\n"
#else
#define ENDLINE "\n"
#endif

//Define the output type of translator.
enum OutputType {
	CUDA, Serial
};

//Class to hold static functions to handle all IO.
class IO {
public:
	//Flag for verbose output.
	bool flagVerbose;

	//Constructor
	IO() {
		flagVerbose = false;
	}

	//Display errors and wait for user interaction
	void Error(std::string errorDescription) {
		fflush(NULL);
		std::cerr << (std::string) errorDescription + " Use -h or --help for help." + ENDLINE;
#ifdef _WIN32
		std::cerr << "Press enter key to terminate the program." << ENDLINE;
		char keyPress;
		do {
			keyPress = getchar();
		} while (keyPress != '\n');
#else
		std::cerr << "Program terminated prematurely." << ENDLINE << ENDLINE;
#endif
		exit(-1);
	}

	//Read XMT Source to a memory.
	std::string ReadProgramFile(std::string fileName) {
		if (flagVerbose) std::cout << (std::string) "Begin to read file : " + fileName + ENDLINE;
		std::fstream xmtProgramFile;
		xmtProgramFile.open(fileName.c_str(), std::fstream::in);
		if (!xmtProgramFile.is_open()) {
			Error((std::string)("Invalid file specified. + ") + (std::string)(fileName));
		}
		std::string xmtProgram = "";
		try {
			xmtProgramFile.seekg(0, std::ios::end);
			xmtProgram.resize((unsigned int) xmtProgramFile.tellg());
			xmtProgramFile.seekg(0, std::ios::beg);
			xmtProgramFile.read(&xmtProgram[0], xmtProgram.size());
		}
		catch (std::exception e) {
			Error("I/O Error");
		}
		xmtProgramFile.close();
		if (flagVerbose) std::cout << (std::string) "Finished reading file : " + fileName + ENDLINE;
		return xmtProgram;
	}

	//Write the output CUDA program to a file.
	void WriteProgram(std::string fileName, std::string program) {
		if (flagVerbose) std::cout << (std::string) "Begin writing to file : " + fileName + ENDLINE;
		std::fstream programFile;
		programFile.open(fileName.c_str(), std::fstream::out);
		if (!programFile.is_open()) {
			IO::Error("Invalid file specified.");
		}
		try {
			programFile << "/* This program has been Auto-generated by XMTtoCUDA converter. */" << ENDLINE;
			programFile << program;
		}
		catch (std::exception e) {
			IO::Error("I/O Error");
		}
		programFile.close();
		if (flagVerbose) std::cout << (std::string) "Finished writing." + ENDLINE;
	}

	//Generate executable and delete source
	void GenerateExecutable(std::string fileName, OutputType type) {
		if (flagVerbose) std::cout << (std::string) "Generating executable : " + fileName + ENDLINE;
		std::string code, outFile = fileName.substr(0, fileName.length() - 3);
		if (type == OutputType::Serial) {
#ifdef _WIN32
			code = "cl " + fileName + " /Ox";
#else
			code = "gcc " + fileName + " -Ofast";
#endif
		}
		else {
#ifdef _WIN32
			code = (std::string) "nvcc -use_fast_math -gencode=arch=compute_20,code=sm_20 -gencode=arch=compute_30,code=sm_30"
				+ " -gencode=arch=compute_35,code=sm_35 -gencode=arch=compute_35,code=compute_35 -O2" + fileName + " -o " + outFile + ".exe";
#else
			code = (std::string) "nvcc -use_fast_math -gencode=arch=compute_20,code=sm_20 -gencode=arch=compute_30,code=sm_30"
				+ "	-gencode=arch=compute_35,code=sm_35 -gencode=arch=compute_35,code=compute_35 -O2 " + fileName + " -o " + outFile + ".o";
#endif
		}
		system(code.c_str());
#ifdef _WIN32
		code = "del " + fileName;
#else
		code = "rm " + fileName;
#endif
		system(code.c_str());
		if (flagVerbose) std::cout << (std::string) "Finished executable : " + fileName + ENDLINE;
	}
};

#endif // !IO_CPP_
